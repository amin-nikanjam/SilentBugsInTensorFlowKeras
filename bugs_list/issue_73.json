{
  "url": "https://api.github.com/repos/tensorflow/tensorflow/issues/36340",
  "repository_url": "https://api.github.com/repos/tensorflow/tensorflow",
  "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/36340/labels{/name}",
  "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/36340/comments",
  "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/36340/events",
  "html_url": "https://github.com/tensorflow/tensorflow/issues/36340",
  "id": 557610972,
  "node_id": "MDU6SXNzdWU1NTc2MTA5NzI=",
  "number": 36340,
  "title": "100-line Tensorflow code and Keras equivalent do not produce the same result, Tensorflow result does not converge, why?",
  "user": {
    "login": "fcunilim",
    "id": 60479342,
    "node_id": "MDQ6VXNlcjYwNDc5MzQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/60479342?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/fcunilim",
    "html_url": "https://github.com/fcunilim",
    "followers_url": "https://api.github.com/users/fcunilim/followers",
    "following_url": "https://api.github.com/users/fcunilim/following{/other_user}",
    "gists_url": "https://api.github.com/users/fcunilim/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/fcunilim/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/fcunilim/subscriptions",
    "organizations_url": "https://api.github.com/users/fcunilim/orgs",
    "repos_url": "https://api.github.com/users/fcunilim/repos",
    "events_url": "https://api.github.com/users/fcunilim/events{/privacy}",
    "received_events_url": "https://api.github.com/users/fcunilim/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 404586594,
      "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=",
      "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower",
      "name": "stat:awaiting tensorflower",
      "color": "f4b400",
      "default": false,
      "description": "Status  - Awaiting response from tensorflower"
    },
    {
      "id": 473172988,
      "node_id": "MDU6TGFiZWw0NzMxNzI5ODg=",
      "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:bug",
      "name": "type:bug",
      "color": "159b2e",
      "default": false,
      "description": "Bug"
    },
    {
      "id": 1097546578,
      "node_id": "MDU6TGFiZWwxMDk3NTQ2NTc4",
      "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/comp:keras",
      "name": "comp:keras",
      "color": "0052cc",
      "default": false,
      "description": "Keras related issues"
    },
    {
      "id": 1548890241,
      "node_id": "MDU6TGFiZWwxNTQ4ODkwMjQx",
      "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/TF%201.15",
      "name": "TF 1.15",
      "color": "e99695",
      "default": false,
      "description": "for issues seen on TF 1.15"
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 5,
  "created_at": "2020-01-30T16:32:18Z",
  "updated_at": "2020-03-10T14:16:41Z",
  "closed_at": "2020-03-04T10:05:17Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "I am doing experiments with a basic GAN, the code of which is provided for both TF (I use version 1.15.2, using TF 2.x-style API) and Keras (2.2.5), below.\r\nThe GAN learns to generate 2D points fitting a 2D curve, f(x) = x^2. Every point is considered as a 2D vector 'individual', (x,y).\r\n\r\nThe following 2 python programs compile and run out-of-the-box, and are meant to produce exactly the same result. However, the TF version **does not converge properly at all**.\r\n\r\nI tried everything I could to understand what's going wrong, to no avail. Obviously, there is something that I miss.\r\n\r\nThe TF version is largely inspired from the official GAN tutorial located here: https://www.tensorflow.org/tutorials/generative/dcgan\r\n\r\nI also provide the code in 2 pastebin links (for your convenience):\r\n\r\nKeras version: https://pastebin.com/N26e3hWh\r\nTensorflow version: https://pastebin.com/9ebmSyJB\r\n\r\nKeras version:\r\n\r\n```\r\nimport numpy as np\r\nfrom numpy import hstack\r\nfrom numpy import zeros\r\nfrom numpy import ones\r\nfrom numpy.random import rand\r\nfrom numpy.random import randn\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Dense\r\nimport keras.backend as K\r\nfrom matplotlib import pyplot\r\n\r\nclass GanPointGraph_Keras(object):\r\n    \r\n    def __init__(self):\r\n        self.latent_dim = 5\r\n        self.discriminator = self.define_discriminator()\r\n        self.generator = self.define_generator(self.latent_dim)\r\n        self.gan_model = self.define_gan(self.generator, self.discriminator)\r\n\r\n    def define_discriminator(self, n_inputs=2):\r\n        model = Sequential()\r\n        model.add(Dense(25, activation='relu', kernel_initializer='he_uniform', input_dim=n_inputs))\r\n        model.add(Dense(1, activation='sigmoid'))\r\n        model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\r\n        print(K.eval(model.optimizer.lr))\r\n        return model\r\n    \r\n    def define_generator(self, latent_dim, n_outputs=2):\r\n        model = Sequential()\r\n        model.add(Dense(15, activation='relu', kernel_initializer='he_uniform', input_dim=latent_dim))\r\n        model.add(Dense(n_outputs, activation='linear'))\r\n        return model\r\n    \r\n    def define_gan(self, generator, discriminator):\r\n        discriminator.trainable = False\r\n        model = Sequential()\r\n        model.add(generator)\r\n        model.add(discriminator)\r\n        model.compile(loss='binary_crossentropy', optimizer='adam')\r\n        return model\r\n    \r\n    def generate_latent_points(self, n):\r\n        x_input = randn(self.latent_dim * n)\r\n        x_input = x_input.reshape(n, self.latent_dim)\r\n        return x_input\r\n    \r\n    def generate_fake_samples(self, n):\r\n        x_input = self.generate_latent_points(n)\r\n        X = self.generator.predict(x_input)\r\n        return X\r\n\r\n    def generate_real_samples(self, n):\r\n        X1 = rand(n) - 0.5\r\n        X2 = X1 * X1\r\n        X1 = X1.reshape(n, 1)\r\n        X2 = X2.reshape(n, 1)\r\n        X = hstack((X1, X2))    \r\n        return X\r\n    \r\n    def train(self):\r\n        n_batch = 128\r\n        half_batch = int(n_batch / 2)\r\n        x_real = self.generate_real_samples(half_batch)\r\n        y_real = ones((half_batch, 1))\r\n        x_fake = self.generate_fake_samples(half_batch)\r\n        y_fake = zeros((half_batch, 1))\r\n        self.discriminator.train_on_batch(x_real, y_real)\r\n        self.discriminator.train_on_batch(x_fake, y_fake)\r\n        x_gan = self.generate_latent_points(n_batch)\r\n        y_gan = ones((n_batch, 1))\r\n        self.gan_model.train_on_batch(x_gan, y_gan)\r\n\r\nif __name__ == \"__main__\":\r\n    g = GanPointGraph_Keras();\r\n\r\n    for epoch in range(10000):\r\n        print('Epoch', epoch)\r\n        g.train()\r\n        if epoch % 1000 == 0:\r\n            g_objects = g.generate_fake_samples(100)\r\n            r_objects = g.generate_real_samples(100)\r\n \r\n            pyplot.clf()\r\n            pyplot.title('Keras iteration ' + str(epoch))\r\n            pyplot.scatter([i[0] for i in r_objects], [i[1] for i in r_objects], c='black')\r\n            pyplot.scatter([i[0] for i in g_objects], [i[1] for i in g_objects], c='red')\r\n            pyplot.show()\r\n```\r\n\r\nTensorflow version:\r\n\r\n```\r\nimport tensorflow as tf\r\ntf.enable_eager_execution() # if using TF 1.15.x\r\nfrom tensorflow.keras import layers\r\n\r\nimport numpy as np\r\nfrom numpy.random import rand\r\nfrom numpy import hstack\r\n\r\nfrom matplotlib import pyplot\r\n\r\nclass GanPointGraph(object):\r\n\r\n    def __init__(self):\r\n        self.latent_dim = 5\r\n        self.generator = self.make_generator()\r\n        self.discriminator = self.make_discriminator()\r\n        \r\n        self.cross_entropy = tf.keras.losses.BinaryCrossentropy(from_logits=True)        \r\n        self.generator_optimizer = tf.keras.optimizers.Adam(learning_rate=0.001)\r\n        self.discriminator_optimizer = tf.keras.optimizers.Adam(learning_rate=0.001)\r\n        \r\n    def make_generator(self):\r\n        model = tf.keras.Sequential()\r\n        model.add(layers.Dense(15, activation='relu', input_dim=self.latent_dim))\r\n        model.add(layers.Dense(2))\r\n        return model\r\n      \r\n    def make_discriminator(self):\r\n        model = tf.keras.Sequential()\r\n        model.add(layers.Dense(25, activation='relu', input_dim=2))\r\n        model.add(layers.Dense(1, activation='sigmoid')) # (-infinity, infinity) -> (0, 1)\r\n        return model\r\n    \r\n    def generator_loss(self, fake_output):\r\n        #return self.cross_entropy(tf.ones_like(fake_output), fake_output)\r\n        return tf.reduce_mean(tf.math.log(1-fake_output))\r\n\r\n    def discriminator_loss(self, real_output, fake_output):\r\n        #real_loss = self.cross_entropy(tf.ones_like(real_output), real_output)\r\n        #fake_loss = self.cross_entropy(tf.zeros_like(fake_output), fake_output)\r\n        #total_loss = real_loss + fake_loss\r\n        #return total_loss\r\n        loss_real = tf.reduce_mean(-tf.math.log(real_output))\r\n        loss_fake = tf.reduce_mean(-tf.math.log(1-fake_output))\r\n        D_loss = loss_real + loss_fake\r\n        return D_loss\r\n\r\n    def generate_real_samples(self, n):\r\n        X1 = rand(n) - 0.5\r\n        X2 = X1 * X1\r\n        X1 = X1.reshape(n, 1)\r\n        X2 = X2.reshape(n, 1)\r\n        x_train = hstack((X1, X2))\r\n        return x_train\r\n    \r\n    def generate_fake_samples(self, n):\r\n        z_sample = np.random.normal(0, 1.0, size=[n, self.latent_dim]).astype(np.float32)\r\n        return self.generator(z_sample, training=False).numpy()\r\n    \r\n    def train(self):\r\n        images = self.generate_real_samples(128);\r\n        noise = tf.random.normal([images.shape[0], self.latent_dim])\r\n        \r\n        with tf.GradientTape() as gen_tape, tf.GradientTape() as disc_tape:\r\n            generated_images = self.generator(noise, training=True)\r\n            \r\n            real_output = self.discriminator(images, training=True)\r\n            fake_output = self.discriminator(generated_images, training=True)\r\n            \r\n            gen_loss = self.generator_loss(fake_output)\r\n            disc_loss = self.discriminator_loss(real_output, fake_output)\r\n        \r\n        gradients_of_generator = gen_tape.gradient(gen_loss, self.generator.trainable_variables)\r\n        gradients_of_discriminator = disc_tape.gradient(disc_loss, self.discriminator.trainable_variables)\r\n        \r\n        self.generator_optimizer.apply_gradients(zip(gradients_of_generator, self.generator.trainable_variables))\r\n        self.discriminator_optimizer.apply_gradients(zip(gradients_of_discriminator, self.discriminator.trainable_variables))\r\n    \r\nif __name__ == \"__main__\":\r\n    g = GanPointGraph();\r\n    \r\n    for epoch in range(10000):\r\n        print('Epoch', epoch)\r\n        g.train()\r\n        if epoch % 1000 == 0:\r\n            g_objects = g.generate_fake_samples(100)\r\n            r_objects = g.generate_real_samples(100)\r\n \r\n            pyplot.clf()\r\n            pyplot.title('Tensorflow iteration ' + str(epoch))\r\n            pyplot.scatter([i[0] for i in r_objects], [i[1] for i in r_objects], c='black')\r\n            pyplot.scatter([i[0] for i in g_objects], [i[1] for i in g_objects], c='red')\r\n            pyplot.show()\r\n```\r\n\r\nIf you run the above programs, you will see that the **Keras version converges quite reliably**. The GAN learns to fit the example points quite nicely. Generate points slowly project onto the curve, and come close to it after about 4000 epochs.\r\n\r\nThe TF version just \"dances around\" the solution, producing quite bad results, even after a high number of epochs. It never really converges. The movement it does is quite funny, navigating on the left, then on the right, and on the left again, and so on. Sometimes, it seems that it starts to fit the curve, but it quickly goes away unfortunately.\r\n\r\nWhat am I doing wrong in Tensorflow? Obviously, there is something that I am missing.\r\n\r\nPlease note:\r\n\r\n- the layers for both versions are the same (initalizers may both be set to 'he_uniform', this does not change the outcome of the test)\r\n- the learning rate is the same (0.001 for both Keras and Tensorflow Adam optimizers)\r\n- I tried with TF 1.15.0 and 1.15.2 runtimes, same result.\r\n- all samples I have tried on my computer seem to work fine.\r\n\r\nI am using Windows x64 and Python 3.6.8 (just the regular Python distribution, not Anaconda).\r\n\r\nHelp would be immensely appreciated as I would like to migrate from Keras to Tensorflow.\r\n\r\nMany thanks in advance.\r\n",
  "closed_by": {
    "login": "tanzhenyu",
    "id": 15220929,
    "node_id": "MDQ6VXNlcjE1MjIwOTI5",
    "avatar_url": "https://avatars.githubusercontent.com/u/15220929?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tanzhenyu",
    "html_url": "https://github.com/tanzhenyu",
    "followers_url": "https://api.github.com/users/tanzhenyu/followers",
    "following_url": "https://api.github.com/users/tanzhenyu/following{/other_user}",
    "gists_url": "https://api.github.com/users/tanzhenyu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tanzhenyu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tanzhenyu/subscriptions",
    "organizations_url": "https://api.github.com/users/tanzhenyu/orgs",
    "repos_url": "https://api.github.com/users/tanzhenyu/repos",
    "events_url": "https://api.github.com/users/tanzhenyu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tanzhenyu/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/tensorflow/tensorflow/issues/36340/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/36340/timeline",
  "performed_via_github_app": null
}
